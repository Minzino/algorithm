package epi;

/*
4.1패리티 계산하기
64비트로 이루어진 숫자가 굉장히 많다면, 패리티를 어떻게 계산해야 할까?
 */
public class Problem4_1 {

//	/*
//	방법 1 64비트를 다 계산한다! 입력 크기가 n일 때, 시간은 O(n)만큼 걸린다.
//	무식하게 푸는 방법
//	 */
//	public static short parity(long x) {
//		short result = 0;
//		while (x != 0) {
//			result ^= (x & 1);
//			x >>>=1;
//		}
//		return result;
//	}

//	/*
//	하위 비트를 한번에 지워서 최선의 경우와 평균적인 경우의 성능을 향상시키는 방법이다.
//	x & (x-1)은 1로 세팅된 비트중 가장 낮은 비트를 지우는 것과 같다.
//	이 비트 조작 트릭을 기억해 두면 시간 복잡도를 줄이는 데 사용할 수 있다.
//	k가 1로 세팅된 비트의 개수라고 하면(예를 들어, 10001010의 경우에 k=3이다.)
//	시간 복잡도는 O(k)가 된다.
//	 */
//	public static short parity(long x) {
//		short result = 0;
//		while (x != 0) {
//			result ^=1;
//			x&=(x-1); //x의 하위 비트를 지운다.
//		}
//		return result;
//	}

	/*
	이 연산은 한 번의 시프트 연산과 한 번의 XOR 연산으로 계산할 수 있다.
	같은 연산을 32,16,8,4,2,1비트 연산에 대해 반복 적용해서 최종 결과를 얻어 낼 수 있다.
	마지막 1과의 연산에서는 그 값을 빼내오기 위해 0x1과 AND 연산을 적용해줘야한다.

	이 경우 단어의 크기가 n일 때, 시간 복잡도는 O(log n)이 된다.
	 */
	public static short parity(long x) {
		x ^= x >>> 32;
		x ^= x >>> 16;
		x ^= x >>> 8;
		x ^= x >>> 4;
		x ^= x >>> 2;
		x ^= x >>> 1;

		return (short) (x & 0x1);
	}

}
